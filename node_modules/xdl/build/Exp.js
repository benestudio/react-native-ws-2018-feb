'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearXDLCacheAsync = exports.resetProjectRandomnessAsync = exports.getProjectRandomnessAsync = exports.sendAsync = exports.recentValidExpsAsync = exports.getPublishInfoAsync = exports.expInfoSafeAsync = exports.saveRecentExpRootAsync = exports.extractTemplateApp = exports.downloadTemplateApp = exports.determineEntryPointAsync = exports.convertProjectAsync = exports.ENTRY_POINT_PLATFORM_TEMPLATE_STRING = undefined;

let determineEntryPointAsync = exports.determineEntryPointAsync = (() => {
  var _ref = _asyncToGenerator(function* (root) {
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(root);

    // entryPoint is relative to the packager root and main is relative
    // to the project root. So if your rn-cli.config.js points to a different
    // root than the project root, these can be different. Most of the time
    // you should use main.
    let entryPoint = pkg.main || 'index.js';
    if (exp && exp.entryPoint) {
      entryPoint = exp.entryPoint;
    }

    return entryPoint;
  });

  return function determineEntryPointAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

let _downloadStarterAppAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (templateId, progressFunction, retryFunction) {
    let versions = yield (_Api || _load_Api()).default.versionsAsync();
    let templateApp = null;
    for (let i = 0; i < versions.templatesv2.length; i++) {
      if (templateId === versions.templatesv2[i].id) {
        templateApp = versions.templatesv2[i];
      }
    }

    if (!templateApp) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_OPTIONS, `No template app with id ${templateId}.`);
    }

    let starterAppVersion = templateApp.version;
    let starterAppName = `${templateId}-${starterAppVersion}`;
    let filename = `${starterAppName}.tar.gz`;
    let starterAppPath = _path.default.join(_starterAppCacheDirectory(), filename);

    if (yield (0, (_existsAsync || _load_existsAsync()).default)(starterAppPath)) {
      return {
        starterAppPath,
        starterAppName
      };
    }

    let url = `https://s3.amazonaws.com/exp-starter-apps/${filename}`;
    yield (_Api || _load_Api()).default.downloadAsync(url, _path.default.join(_starterAppCacheDirectory(), filename), {}, progressFunction, retryFunction);
    return {
      starterAppPath,
      starterAppName
    };
  });

  return function _downloadStarterAppAsync(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

let downloadTemplateApp = exports.downloadTemplateApp = (() => {
  var _ref3 = _asyncToGenerator(function* (templateId, selectedDir, opts) {
    // Validate
    let schema = (_joi || _load_joi()).default.object().keys({
      name: (_joi || _load_joi()).default.string().required()
    });

    // Should we validate that name is a valid name here?
    try {
      yield validateAsync({ name: opts.name }, schema);
    } catch (e) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_OPTIONS, e.toString());
    }
    let name = opts.name;
    let root = _path.default.join(selectedDir, name);

    (_Analytics || _load_Analytics()).logEvent('New Project', {
      selectedDir,
      name
    });

    let fileExists = true;
    try {
      // If file doesn't exist it will throw an error.
      // Don't want to continue unless there is nothing there.
      _fs.default.statSync(root);
    } catch (e) {
      fileExists = false;
    }
    // This check is required because without it, the retry button would throw an error because the directory already exists,
    // even though it is empty.
    if (fileExists && _fs.default.readdirSync(root).length !== 0) {
      throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.DIRECTORY_ALREADY_EXISTS, `That directory already exists. Please choose a different parent directory or project name.`);
    }

    // Download files
    yield mkdirpAsync(root);
    (_Logger || _load_Logger()).default.notifications.info({ code: (_NotificationCode || _load_NotificationCode()).default.PROGRESS }, (_MessageCode || _load_MessageCode()).default.DOWNLOADING);
    let { starterAppPath } = yield _downloadStarterAppAsync(templateId, opts.progressFunction, opts.retryFunction);
    return { starterAppPath, name, root };
  });

  return function downloadTemplateApp(_x5, _x6, _x7) {
    return _ref3.apply(this, arguments);
  };
})();

let extractTemplateApp = exports.extractTemplateApp = (() => {
  var _ref4 = _asyncToGenerator(function* (starterAppPath, name, root) {
    (_Logger || _load_Logger()).default.notifications.info({ code: (_NotificationCode || _load_NotificationCode()).default.PROGRESS }, (_MessageCode || _load_MessageCode()).default.EXTRACTING);
    yield (_Extract || _load_Extract()).extractAsync(starterAppPath, root);

    // Update files
    (_Logger || _load_Logger()).default.notifications.info({ code: (_NotificationCode || _load_NotificationCode()).default.PROGRESS }, (_MessageCode || _load_MessageCode()).default.CUSTOMIZING);

    // Update app.json
    let appJson = yield readFileAsync(_path.default.join(root, 'app.json'), 'utf8');
    let customAppJson = appJson.replace(/\"My New Project\"/, `"${name}"`).replace(/\"my-new-project\"/, `"${name}"`);
    yield writeFileAsync(_path.default.join(root, 'app.json'), customAppJson, 'utf8');

    yield initGitRepo(root);

    (_Logger || _load_Logger()).default.notifications.info({ code: (_NotificationCode || _load_NotificationCode()).default.PROGRESS }, 'Starting project...');

    return root;
  });

  return function extractTemplateApp(_x8, _x9, _x10) {
    return _ref4.apply(this, arguments);
  };
})();

let initGitRepo = (() => {
  var _ref5 = _asyncToGenerator(function* (root) {
    if (process.platform === 'darwin' && !(_Binaries || _load_Binaries()).isXcodeInstalled()) {
      (_Logger || _load_Logger()).default.global.warn(`Unable to initialize git repo. \`git\` not installed.`);
      return;
    }

    // let's see if we're in a git tree
    let insideGit = true;
    try {
      yield (0, (_spawnAsync || _load_spawnAsync()).default)('git', ['rev-parse', '--is-inside-work-tree'], {
        cwd: root
      });
      (_Logger || _load_Logger()).default.global.debug('New project is already inside of a git repo, skipping git init.');
    } catch (e) {
      insideGit = false;
    }

    if (!insideGit) {
      try {
        yield (0, (_spawnAsync || _load_spawnAsync()).default)('git', ['init'], { cwd: root });
      } catch (e) {
        // no-op -- this is just a convenience and we don't care if it fails
      }
    }
  });

  return function initGitRepo(_x11) {
    return _ref5.apply(this, arguments);
  };
})();

let saveRecentExpRootAsync = exports.saveRecentExpRootAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (root) {
    root = _path.default.resolve(root);

    // Write the recent Exps JSON file
    let recentExpsJsonFile = (_UserSettings || _load_UserSettings()).default.recentExpsJsonFile();
    let recentExps = yield recentExpsJsonFile.readAsync();
    // Filter out copies of this so we don't get dupes in this list
    recentExps = recentExps.filter(function (x) {
      return x !== root;
    });
    recentExps.unshift(root);
    return yield recentExpsJsonFile.writeAsync(recentExps.slice(0, 100));
  });

  return function saveRecentExpRootAsync(_x12) {
    return _ref6.apply(this, arguments);
  };
})();

let expInfoSafeAsync = exports.expInfoSafeAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (root) {
    try {
      let { exp: { name, description, icon, iconUrl } } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(root);
      let pathOrUrl = icon || iconUrl || 'https://d3lwq5rlu14cro.cloudfront.net/ExponentEmptyManifest_192.png';
      let resolvedPath = _path.default.resolve(root, pathOrUrl);
      if (_fs.default.existsSync(resolvedPath)) {
        icon = `file://${resolvedPath}`;
      } else {
        icon = pathOrUrl; // Assume already a URL
      }

      return {
        readableRoot: makePathReadable(root),
        root,
        name,
        description,
        icon
      };
    } catch (e) {
      return null;
    }
  });

  return function expInfoSafeAsync(_x13) {
    return _ref7.apply(this, arguments);
  };
})();

// TODO: remove / change, no longer publishInfo, this is just used for signing
let getPublishInfoAsync = exports.getPublishInfoAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (root) {
    const user = yield (_User || _load_User()).default.ensureLoggedInAsync();

    if (!user) {
      throw new Error('Attempted to login in offline mode. This is a bug.');
    }

    const { username } = user;

    const { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(root);

    const name = exp.slug;
    const version = exp.version;

    const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(root);

    if (!exp || !exp.sdkVersion) {
      throw new Error(`sdkVersion is missing from ${configName}`);
    }

    if (!name) {
      // slug is made programmatically for app.json
      throw new Error(`slug field is missing from exp.json.`);
    }

    if (!version) {
      throw new Error(`Can't get version of package.`);
    }

    let remotePackageName = name;
    let remoteUsername = username;
    let remoteFullPackageName = `@${remoteUsername}/${remotePackageName}`;
    let bundleIdentifierIOS = exp.ios ? exp.ios.bundleIdentifier : null;
    let packageNameAndroid = exp.android ? exp.android.package : null;

    return {
      args: {
        username,
        remoteUsername,
        remotePackageName,
        remoteFullPackageName,
        bundleIdentifierIOS,
        packageNameAndroid // TODO: this isn't used anywhere
      }
    };
  });

  return function getPublishInfoAsync(_x14) {
    return _ref8.apply(this, arguments);
  };
})();

let recentValidExpsAsync = exports.recentValidExpsAsync = (() => {
  var _ref9 = _asyncToGenerator(function* () {
    let recentExpsJsonFile = (_UserSettings || _load_UserSettings()).default.recentExpsJsonFile();
    let recentExps = yield recentExpsJsonFile.readAsync();

    let results = yield Promise.all(recentExps.map(expInfoSafeAsync));
    let filteredResults = results.filter(function (result) {
      return result;
    });
    return filteredResults;
  });

  return function recentValidExpsAsync() {
    return _ref9.apply(this, arguments);
  };
})();

let sendAsync = exports.sendAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (recipient, url_) {
    let result = yield (_Api || _load_Api()).default.callMethodAsync('send', [recipient, url_]);
    return result;
  });

  return function sendAsync(_x15, _x16) {
    return _ref10.apply(this, arguments);
  };
})();

// TODO: figure out where these functions should live


let getProjectRandomnessAsync = exports.getProjectRandomnessAsync = (() => {
  var _ref11 = _asyncToGenerator(function* (projectRoot) {
    let ps = yield (_ProjectSettings || _load_ProjectSettings()).readAsync(projectRoot);
    let randomness = ps.urlRandomness;
    if (randomness) {
      return randomness;
    } else {
      return resetProjectRandomnessAsync(projectRoot);
    }
  });

  return function getProjectRandomnessAsync(_x17) {
    return _ref11.apply(this, arguments);
  };
})();

let resetProjectRandomnessAsync = exports.resetProjectRandomnessAsync = (() => {
  var _ref12 = _asyncToGenerator(function* (projectRoot) {
    let randomness = (_UrlUtils || _load_UrlUtils()).someRandomness();
    (_ProjectSettings || _load_ProjectSettings()).setAsync(projectRoot, { urlRandomness: randomness });
    return randomness;
  });

  return function resetProjectRandomnessAsync(_x18) {
    return _ref12.apply(this, arguments);
  };
})();

let clearXDLCacheAsync = exports.clearXDLCacheAsync = (() => {
  var _ref13 = _asyncToGenerator(function* () {
    let dotExpoHomeDirectory = (_UserSettings || _load_UserSettings()).default.dotExpoHomeDirectory();
    (_rimraf || _load_rimraf()).default.sync(_path.default.join(dotExpoHomeDirectory, 'ios-simulator-app-cache'));
    (_rimraf || _load_rimraf()).default.sync(_path.default.join(dotExpoHomeDirectory, 'android-apk-cache'));
    (_rimraf || _load_rimraf()).default.sync(_path.default.join(dotExpoHomeDirectory, 'starter-app-cache'));
    (_Logger || _load_Logger()).default.notifications.info(`Cleared cache`);
  });

  return function clearXDLCacheAsync() {
    return _ref13.apply(this, arguments);
  };
})();

var _Convert;

function _load_Convert() {
  return _Convert = require('./project/Convert');
}

Object.defineProperty(exports, 'convertProjectAsync', {
  enumerable: true,
  get: function () {
    return _interopRequireDefault(_Convert || _load_Convert()).default;
  }
});

var _util;

function _load_util() {
  return _util = _interopRequireDefault(require('util.promisify'));
}

var _existsAsync;

function _load_existsAsync() {
  return _existsAsync = _interopRequireDefault(require('exists-async'));
}

var _fs = _interopRequireDefault(require('fs'));

var _mkdirp;

function _load_mkdirp() {
  return _mkdirp = _interopRequireDefault(require('mkdirp'));
}

var _path = _interopRequireDefault(require('path'));

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@expo/spawn-async'));
}

var _jsonFile;

function _load_jsonFile() {
  return _jsonFile = _interopRequireDefault(require('@expo/json-file'));
}

var _joi;

function _load_joi() {
  return _joi = _interopRequireDefault(require('joi'));
}

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _Analytics;

function _load_Analytics() {
  return _Analytics = _interopRequireWildcard(require('./Analytics'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('./Api'));
}

var _Binaries;

function _load_Binaries() {
  return _Binaries = _interopRequireWildcard(require('./Binaries'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('./ErrorCode'));
}

var _Extract;

function _load_Extract() {
  return _Extract = _interopRequireWildcard(require('./Extract'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

var _NotificationCode;

function _load_NotificationCode() {
  return _NotificationCode = _interopRequireDefault(require('./NotificationCode'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('./project/ProjectUtils'));
}

var _User;

function _load_User() {
  return _User = _interopRequireDefault(require('./User'));
}

var _UrlUtils;

function _load_UrlUtils() {
  return _UrlUtils = _interopRequireWildcard(require('./UrlUtils'));
}

var _UserSettings;

function _load_UserSettings() {
  return _UserSettings = _interopRequireDefault(require('./UserSettings'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('./XDLError'));
}

var _ProjectSettings;

function _load_ProjectSettings() {
  return _ProjectSettings = _interopRequireWildcard(require('./ProjectSettings'));
}

var _MessageCode;

function _load_MessageCode() {
  return _MessageCode = _interopRequireDefault(require('./MessageCode'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// FIXME(perry) eliminate usage of this template
const ENTRY_POINT_PLATFORM_TEMPLATE_STRING = exports.ENTRY_POINT_PLATFORM_TEMPLATE_STRING = 'PLATFORM_GOES_HERE';

const readFileAsync = (0, (_util || _load_util()).default)(_fs.default.readFile);
const writeFileAsync = (0, (_util || _load_util()).default)(_fs.default.writeFile);
const validateAsync = (0, (_util || _load_util()).default)((_joi || _load_joi()).default.validate);
const mkdirpAsync = (0, (_util || _load_util()).default)((_mkdirp || _load_mkdirp()).default);

function _starterAppCacheDirectory() {
  let dotExpoHomeDirectory = (_UserSettings || _load_UserSettings()).default.dotExpoHomeDirectory();
  let dir = _path.default.join(dotExpoHomeDirectory, 'starter-app-cache');
  (_mkdirp || _load_mkdirp()).default.sync(dir);
  return dir;
}

function getHomeDir() {
  return process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'] || '';
}

function makePathReadable(pth) {
  let homedir = getHomeDir();
  if (pth.substr(0, homedir.length) === homedir) {
    return `~${pth.substr(homedir.length)}`;
  } else {
    return pth;
  }
}
//# sourceMappingURL=__sourcemaps__/Exp.js.map
