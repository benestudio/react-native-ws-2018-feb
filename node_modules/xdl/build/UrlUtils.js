'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constructUrlAsync = exports.constructBundleQueryParamsAsync = exports.constructDebuggerHostAsync = exports.constructAssetsUrlAsync = exports.constructSourceMapUrlAsync = exports.constructPublishUrlAsync = exports.constructUrlWithExtensionAsync = exports.constructLogUrlAsync = exports.constructManifestUrlAsync = exports.constructBundleUrlAsync = undefined;

let constructBundleUrlAsync = exports.constructBundleUrlAsync = (() => {
  var _ref = _asyncToGenerator(function* (projectRoot, opts, requestHostname) {
    return constructUrlAsync(projectRoot, opts, true, requestHostname);
  });

  return function constructBundleUrlAsync(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

let constructManifestUrlAsync = exports.constructManifestUrlAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectRoot, opts, requestHostname) {
    return constructUrlAsync(projectRoot, opts, false, requestHostname);
  });

  return function constructManifestUrlAsync(_x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
})();

let constructLogUrlAsync = exports.constructLogUrlAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (projectRoot, requestHostname) {
    let baseUrl = yield constructUrlAsync(projectRoot, { urlType: 'http' }, false, requestHostname);
    return `${baseUrl}/logs`;
  });

  return function constructLogUrlAsync(_x7, _x8) {
    return _ref3.apply(this, arguments);
  };
})();

let constructUrlWithExtensionAsync = exports.constructUrlWithExtensionAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (projectRoot, entryPoint, ext, requestHostname) {
    let bundleUrl = yield constructBundleUrlAsync(projectRoot, {
      hostType: 'localhost',
      urlType: 'http'
    }, requestHostname);

    let mainModulePath = guessMainModulePath(entryPoint);
    bundleUrl += `/${mainModulePath}.${ext}`;

    let queryParams = yield constructBundleQueryParamsAsync(projectRoot, {
      dev: false,
      minify: true
    }, requestHostname);
    return `${bundleUrl}?${queryParams}`;
  });

  return function constructUrlWithExtensionAsync(_x9, _x10, _x11, _x12) {
    return _ref4.apply(this, arguments);
  };
})();

let constructPublishUrlAsync = exports.constructPublishUrlAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (projectRoot, entryPoint, requestHostname) {
    return yield constructUrlWithExtensionAsync(projectRoot, entryPoint, 'bundle', requestHostname);
  });

  return function constructPublishUrlAsync(_x13, _x14, _x15) {
    return _ref5.apply(this, arguments);
  };
})();

let constructSourceMapUrlAsync = exports.constructSourceMapUrlAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (projectRoot, entryPoint, requestHostname) {
    return yield constructUrlWithExtensionAsync(projectRoot, entryPoint, 'map', requestHostname);
  });

  return function constructSourceMapUrlAsync(_x16, _x17, _x18) {
    return _ref6.apply(this, arguments);
  };
})();

let constructAssetsUrlAsync = exports.constructAssetsUrlAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (projectRoot, entryPoint, requestHostname) {
    return yield constructUrlWithExtensionAsync(projectRoot, entryPoint, 'assets', requestHostname);
  });

  return function constructAssetsUrlAsync(_x19, _x20, _x21) {
    return _ref7.apply(this, arguments);
  };
})();

let constructDebuggerHostAsync = exports.constructDebuggerHostAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (projectRoot, requestHostname) {
    return constructUrlAsync(projectRoot, {
      urlType: 'no-protocol'
    }, true, requestHostname);
  });

  return function constructDebuggerHostAsync(_x22, _x23) {
    return _ref8.apply(this, arguments);
  };
})();

let constructBundleQueryParamsAsync = exports.constructBundleQueryParamsAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (projectRoot, opts) {
    let queryParams = `dev=${encodeURIComponent(!!opts.dev)}`;

    if (opts.hasOwnProperty('strict')) {
      queryParams += `&strict=${encodeURIComponent(!!opts.strict)}`;
    }

    if (opts.hasOwnProperty('minify')) {
      queryParams += `&minify=${encodeURIComponent(!!opts.minify)}`;
    }

    queryParams += '&hot=false';

    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);

    // Be backwards compatible for users who haven't migrated from `exponent`
    // to the `expo` sdk package.
    let sdkPkg = pkg.dependencies['expo'] ? 'expo' : 'exponent';
    // Use an absolute path here so that we can not worry about symlinks/relative requires
    let nodeModulesPath = exp.nodeModulesPath ? _path.default.join(_path.default.resolve(projectRoot, exp.nodeModulesPath), 'node_modules') : _path.default.join(projectRoot, 'node_modules');
    let pluginModule = _path.default.join(nodeModulesPath, sdkPkg, 'tools', 'hashAssetFiles');
    queryParams += `&assetPlugin=${pluginModule}`;

    // Only sdk-10.1.0+ supports the assetPlugin parameter. We use only the
    // major version in the sdkVersion field, so check for 11.0.0 to be sure.
    let supportsAssetPlugins = (_Versions || _load_Versions()).gteSdkVersion(exp, '11.0.0');
    if (!supportsAssetPlugins) {
      queryParams += '&includeAssetFileHashes=true';
    }

    return queryParams;
  });

  return function constructBundleQueryParamsAsync(_x24, _x25) {
    return _ref9.apply(this, arguments);
  };
})();

let constructUrlAsync = exports.constructUrlAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (projectRoot, opts, isPackager, requestHostname) {
    if (opts) {
      // the randomness is only important if we're online and can build a tunnel
      let urlRandomnessSchema;
      if ((_Config || _load_Config()).default.offline) {
        urlRandomnessSchema = (_joi || _load_joi()).default.string().optional().allow(null);
      } else {
        urlRandomnessSchema = (_joi || _load_joi()).default.string();
      }

      let schema = (_joi || _load_joi()).default.object().keys({
        urlType: (_joi || _load_joi()).default.any().valid('exp', 'http', 'redirect', 'no-protocol'),
        lanType: (_joi || _load_joi()).default.any().valid('ip', 'hostname'),
        hostType: (_joi || _load_joi()).default.any().valid('localhost', 'lan', 'tunnel'),
        dev: (_joi || _load_joi()).default.boolean(),
        strict: (_joi || _load_joi()).default.boolean(),
        minify: (_joi || _load_joi()).default.boolean(),
        urlRandomness: urlRandomnessSchema
      });

      try {
        yield joiValidateAsync(opts, schema);
      } catch (e) {
        throw new (_XDLError || _load_XDLError()).default((_ErrorCode || _load_ErrorCode()).default.INVALID_OPTIONS, e.toString());
      }
    }

    let defaultOpts = yield (_ProjectSettings || _load_ProjectSettings()).getPackagerOptsAsync(projectRoot);
    if (!opts) {
      opts = defaultOpts;
    } else {
      opts = Object.assign({}, defaultOpts, opts);
    }

    let packagerInfo = yield (_ProjectSettings || _load_ProjectSettings()).readPackagerInfoAsync(projectRoot);

    let protocol;
    if (opts.urlType === 'http') {
      protocol = 'http';
    } else if (opts.urlType === 'no-protocol') {
      protocol = null;
    } else {
      protocol = 'exp';

      let { exp } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
      if (exp.detach && exp.detach.scheme) {
        protocol = exp.detach.scheme;
      }
    }

    let hostname;
    let port;

    const proxyURL = isPackager ? process.env.EXPO_PACKAGER_PROXY_URL : process.env.EXPO_MANIFEST_PROXY_URL;
    if (proxyURL) {
      const parsedProxyURL = _url.default.parse(proxyURL);
      hostname = parsedProxyURL.hostname;
      port = parsedProxyURL.port;
      if (parsedProxyURL.protocol === 'https:') {
        if (protocol === 'http') {
          protocol = 'https';
        }
        if (!port) {
          port = '443';
        }
      }
    } else if (opts.hostType === 'localhost' || requestHostname === 'localhost') {
      hostname = 'localhost';
      port = isPackager ? packagerInfo.packagerPort : packagerInfo.expoServerPort;
    } else if (opts.hostType === 'lan' || (_Config || _load_Config()).default.offline) {
      if (process.env.EXPO_PACKAGER_HOSTNAME) {
        hostname = process.env.EXPO_PACKAGER_HOSTNAME;
      } else if (process.env.REACT_NATIVE_PACKAGER_HOSTNAME) {
        hostname = process.env.REACT_NATIVE_PACKAGER_HOSTNAME;
      } else if (opts.lanType === 'ip') {
        if (requestHostname) {
          hostname = requestHostname;
        } else {
          hostname = (_ip || _load_ip()).default.address();
        }
      } else {
        // Some old versions of OSX work with hostname but not local ip address.
        hostname = _os.default.hostname();
      }
      port = isPackager ? packagerInfo.packagerPort : packagerInfo.expoServerPort;
    } else {
      let ngrokUrl = isPackager ? packagerInfo.packagerNgrokUrl : packagerInfo.expoServerNgrokUrl;
      if (!ngrokUrl) {
        // use localhost
        hostname = 'localhost';
        port = isPackager ? packagerInfo.packagerPort : packagerInfo.expoServerPort;

        // TODO report a warning when this is for a currently served project, suppress for status checks
      } else {
        let pnu = _url.default.parse(ngrokUrl);
        hostname = pnu.hostname;
        port = pnu.port;
      }
    }

    let url_ = '';
    if (protocol) {
      url_ += `${protocol}://`;
    }

    if (!hostname) {
      throw new Error('Hostname cannot be inferred.');
    }

    url_ += hostname;

    if (port) {
      url_ += `:${port}`;
    } else {
      // Android HMR breaks without this :|
      url_ += ':80';
    }

    if (opts.urlType === 'redirect') {
      return `https://exp.host/--/to-exp/${encodeURIComponent(url_)}`;
    }

    return url_;
  });

  return function constructUrlAsync(_x26, _x27, _x28, _x29) {
    return _ref10.apply(this, arguments);
  };
})();

exports.guessMainModulePath = guessMainModulePath;
exports.randomIdentifier = randomIdentifier;
exports.sevenDigitIdentifier = sevenDigitIdentifier;
exports.randomIdentifierForUser = randomIdentifierForUser;
exports.someRandomness = someRandomness;
exports.domainify = domainify;
exports.getPlatformSpecificBundleUrl = getPlatformSpecificBundleUrl;

var _joi;

function _load_joi() {
  return _joi = _interopRequireDefault(require('joi'));
}

var _os = _interopRequireDefault(require('os'));

var _path = _interopRequireDefault(require('path'));

var _url = _interopRequireDefault(require('url'));

var _util;

function _load_util() {
  return _util = _interopRequireDefault(require('util.promisify'));
}

var _ip;

function _load_ip() {
  return _ip = _interopRequireDefault(require('./ip'));
}

var _Config;

function _load_Config() {
  return _Config = _interopRequireDefault(require('./Config'));
}

var _ErrorCode;

function _load_ErrorCode() {
  return _ErrorCode = _interopRequireDefault(require('./ErrorCode'));
}

var _Exp;

function _load_Exp() {
  return _Exp = _interopRequireWildcard(require('./Exp'));
}

var _ProjectSettings;

function _load_ProjectSettings() {
  return _ProjectSettings = _interopRequireWildcard(require('./ProjectSettings'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('./project/ProjectUtils'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('./Versions'));
}

var _XDLError;

function _load_XDLError() {
  return _XDLError = _interopRequireDefault(require('./XDLError'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const joiValidateAsync = (0, (_util || _load_util()).default)((_joi || _load_joi()).default.validate);

function guessMainModulePath(entryPoint) {
  return entryPoint.replace(/\.js$/, '');
}

function randomIdentifier(length = 6) {
  let alphabet = '23456789qwertyuipasdfghjkzxcvbnm';
  let result = '';
  for (let i = 0; i < length; i++) {
    let j = Math.floor(Math.random() * alphabet.length);
    let c = alphabet.substr(j, 1);
    result += c;
  }
  return result;
}

function sevenDigitIdentifier() {
  return `${randomIdentifier(3)}-${randomIdentifier(4)}`;
}

function randomIdentifierForUser(username) {
  return `${username}-${randomIdentifier(3)}-${randomIdentifier(2)}`;
}

function someRandomness() {
  return [randomIdentifier(2), randomIdentifier(3)].join('-');
}

function domainify(s) {
  return s.toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/^-+/, '').replace(/-+$/, '');
}

function getPlatformSpecificBundleUrl(url, platform) {
  if (url.includes((_Exp || _load_Exp()).ENTRY_POINT_PLATFORM_TEMPLATE_STRING)) {
    return url.replace((_Exp || _load_Exp()).ENTRY_POINT_PLATFORM_TEMPLATE_STRING, platform);
  } else {
    return url;
  }
}
//# sourceMappingURL=__sourcemaps__/UrlUtils.js.map
