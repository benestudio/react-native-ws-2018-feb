'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExpoSdkStatus = exports.EXPO_SDK_NOT_IMPORTED = exports.EXPO_SDK_NOT_INSTALLED = exports.EXPO_SDK_INSTALLED_AND_IMPORTED = exports.validateWithNetworkAsync = exports.validateLowLatencyAsync = exports.validateWithSchema = exports.validateWithSchemaFileAsync = exports.FATAL = exports.ERROR = exports.WARNING = exports.NO_ISSUES = undefined;

let _checkNpmVersionAsync = (() => {
  var _ref = _asyncToGenerator(function* (projectRoot) {
    try {
      yield (_Binaries || _load_Binaries()).sourceBashLoginScriptsAsync();

      try {
        let yarnVersionResponse = yield (0, (_spawnAsync || _load_spawnAsync()).default)('yarnpkg', ['--version']);
        if (yarnVersionResponse.status === 0) {
          return NO_ISSUES;
        }
      } catch (e) {}

      let npmVersionResponse = yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['--version']);
      let npmVersion = (_lodash || _load_lodash()).default.trim(npmVersionResponse.stdout);

      if ((_semver || _load_semver()).default.lt(npmVersion, MIN_NPM_VERSION) || _isNpmVersionWithinRanges(npmVersion, BAD_NPM_VERSION_RANGES)) {
        (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: You are using npm version ${npmVersion}. We recommend version ${CORRECT_NPM_VERSION}. To install it, run 'npm i -g npm@${CORRECT_NPM_VERSION}'.`, 'doctor-npm-version');
        return WARNING;
      } else if (_isNpmVersionWithinRanges(npmVersion, WARN_NPM_VERSION_RANGES)) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: You are using npm version ${npmVersion}. There may be bugs in this version, use it at your own risk. We recommend version ${CORRECT_NPM_VERSION}.`, 'doctor-npm-version');
      } else {
        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-npm-version');
      }
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Could not determine npm version. Make sure your version is >= ${MIN_NPM_VERSION} - we recommend ${CORRECT_NPM_VERSION}.`, 'doctor-npm-version');
      return WARNING;
    }

    return NO_ISSUES;
  });

  return function _checkNpmVersionAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

let _checkWatchmanVersionAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectRoot) {
    // There's no point in checking any of this stuff if watchman isn't supported on this platform
    if (!(_Watchman || _load_Watchman()).isPlatformSupported()) {
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-watchman-version');
      return;
    }

    let watchmanVersion = yield (_Watchman || _load_Watchman()).unblockAndGetVersionAsync(projectRoot);

    // If we can't get the watchman version, `getVersionAsync` will return `null`
    if (!watchmanVersion) {
      // watchman is probably just not installed
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-watchman-version');
      return;
    }

    if ((_semver || _load_semver()).default.lt(watchmanVersion, MIN_WATCHMAN_VERSION)) {
      let warningMessage = `Warning: You are using an old version of watchman (v${watchmanVersion}). This may cause problems for you.\n\nWe recommend that you either uninstall watchman (and XDE will try to use a copy it is bundled with) or upgrade watchman to a newer version, at least v${MIN_WATCHMAN_VERSION}.`;

      // Add a note about homebrew if the user is on a Mac
      if (process.platform === 'darwin') {
        warningMessage += `\n\nIf you are using homebrew, try:\nbrew uninstall watchman; brew install watchman`;
      }
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', warningMessage, 'doctor-watchman-version');
    } else {
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-watchman-version');
    }
  });

  return function _checkWatchmanVersionAsync(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

let validateWithSchemaFileAsync = exports.validateWithSchemaFileAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (projectRoot, schemaPath) {
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    let schema = JSON.parse((yield (_fsExtra || _load_fsExtra()).default.readFile(schemaPath, 'utf8')));
    return validateWithSchema(projectRoot, exp, schema.schema, 'exp.json', 'UNVERSIONED', true);
  });

  return function validateWithSchemaFileAsync(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
})();

let validateWithSchema = exports.validateWithSchema = (() => {
  var _ref4 = _asyncToGenerator(function* (projectRoot, exp, schema, configName, sdkVersion, validateAssets) {
    let schemaErrorMessage;
    let assetsErrorMessage;
    let validator = new (_schemer || _load_schemer()).default(schema, { rootDir: projectRoot });

    // Validate the schema itself
    try {
      yield validator.validateSchemaAsync(exp);
    } catch (e) {
      if (e instanceof (_schemer2 || _load_schemer2()).SchemerError) {
        schemaErrorMessage = `Error: Problem${e.errors.length > 1 ? 's' : ''} validating fields in ${configName}. See https://docs.expo.io/versions/v${sdkVersion}/guides/configuration.html.`;
        schemaErrorMessage += e.errors.map(formatValidationError).join('');
      }
    }

    if (validateAssets) {
      try {
        yield validator.validateAssetsAsync(exp);
      } catch (e) {
        if (e instanceof (_schemer2 || _load_schemer2()).SchemerError) {
          assetsErrorMessage = `Error: Problem${e.errors.length > 1 ? '' : 's'} validating asset fields in ${configName}. See ${(_Config || _load_Config()).default.helpUrl}`;
          assetsErrorMessage += e.errors.map(formatValidationError).join('');
        }
      }
    }
    return { schemaErrorMessage, assetsErrorMessage };
  });

  return function validateWithSchema(_x5, _x6, _x7, _x8, _x9, _x10) {
    return _ref4.apply(this, arguments);
  };
})();

let _validatePackageJsonAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (exp, pkg, projectRoot) {
    // TODO: Check any native module versions here
    if ((_Config || _load_Config()).default.validation.reactNativeVersionWarnings) {
      let reactNative = pkg.dependencies['react-native'];

      // Expo fork of react-native is required
      if (!reactNative.match(/expo\/react-native/)) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Not using the Expo fork of react-native. See ${(_Config || _load_Config()).default.helpUrl}.`, 'doctor-not-using-expo-fork');
        return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-not-using-expo-fork');

      let sdkVersions = yield (_Api || _load_Api()).default.sdkVersionsAsync();
      let sdkVersion = exp.sdkVersion;
      try {
        let reactNativeTag = reactNative.match(/sdk-\d+\.\d+\.\d+/)[0];
        let sdkVersionObject = sdkVersions[sdkVersion];

        // TODO: Want to be smarter about this. Maybe warn if there's a newer version.
        if ((_semver || _load_semver()).default.major((_Versions || _load_Versions()).parseSdkVersionFromTag(reactNativeTag)) !== (_semver || _load_semver()).default.major((_Versions || _load_Versions()).parseSdkVersionFromTag(sdkVersionObject['expoReactNativeTag']))) {
          (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Invalid version of react-native for sdkVersion ${sdkVersion}. Use github:expo/react-native#${sdkVersionObject['expoReactNativeTag']}`, 'doctor-invalid-version-of-react-native');
          return WARNING;
        }
        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-invalid-version-of-react-native');

        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-malformed-version-of-react-native');
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: ${reactNative} is not a valid version. Version must be in the form of sdk-x.y.z. Please update your package.json file.`, 'doctor-malformed-version-of-react-native');
        return WARNING;
      }
    }
    return NO_ISSUES;
  });

  return function _validatePackageJsonAsync(_x11, _x12, _x13) {
    return _ref5.apply(this, arguments);
  };
})();

let _validateExpJsonAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (exp, pkg, projectRoot, allowNetwork) {
    if (!exp || !pkg) {
      // readConfigJsonAsync already logged an error
      return FATAL;
    }

    try {
      yield _checkWatchmanVersionAsync(projectRoot);
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Problem checking watchman version. ${e.message}.`, 'doctor-problem-checking-watchman-version');
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-problem-checking-watchman-version');

    const expJsonExists = yield (_ProjectUtils || _load_ProjectUtils()).fileExistsAsync(_path.default.join(projectRoot, 'exp.json'));
    const appJsonExists = yield (_ProjectUtils || _load_ProjectUtils()).fileExistsAsync(_path.default.join(projectRoot, 'app.json'));

    if (expJsonExists && appJsonExists) {
      (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Both app.json and exp.json exist in this directory. Only one should exist for a single project.`, 'doctor-both-app-and-exp-json');
      return WARNING;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-both-app-and-exp-json');

    let sdkVersion = exp.sdkVersion;
    const configName = yield (_ProjectUtils || _load_ProjectUtils()).configFilenameAsync(projectRoot);

    // Skip validation if the correct token is set in env
    if (!(sdkVersion === 'UNVERSIONED' && process.env.EXPO_SKIP_MANIFEST_VALIDATION_TOKEN)) {
      try {
        let schema = yield (_ExpSchema || _load_ExpSchema()).getSchemaAsync(sdkVersion);
        let { schemaErrorMessage, assetsErrorMessage } = yield validateWithSchema(projectRoot, exp, schema, configName, sdkVersion, allowNetwork);

        if (schemaErrorMessage) {
          (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', schemaErrorMessage, 'doctor-schema-validation');
        } else {
          (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-schema-validation');
        }
        if (assetsErrorMessage) {
          (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', assetsErrorMessage, `doctor-validate-asset-fields`);
        } else {
          (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, `doctor-validate-asset-fields`);
        }
        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-schema-validation-exception');
        if (schemaErrorMessage || assetsErrorMessage) return ERROR;
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Problem validating ${configName}: ${e.message}.`, 'doctor-schema-validation-exception');
      }
    }

    // Warn if sdkVersion is UNVERSIONED
    if (sdkVersion === 'UNVERSIONED' && !process.env.EXPO_SKIP_MANIFEST_VALIDATION_TOKEN) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: Using unversioned Expo SDK. Do not publish until you set sdkVersion in ${configName}`, 'doctor-unversioned');
      return ERROR;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-unversioned');

    // react-native is required
    if (!pkg.dependencies || !pkg.dependencies['react-native']) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: Can't find react-native in package.json dependencies`, 'doctor-no-react-native-in-package-json');
      return ERROR;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-no-react-native-in-package-json');

    let sdkVersions = yield (_Api || _load_Api()).default.sdkVersionsAsync();
    if (!sdkVersions) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: Couldn't connect to SDK versions server`, 'doctor-versions-endpoint-failed');
      return ERROR;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-versions-endpoint-failed');

    if (!sdkVersions[sdkVersion]) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: Invalid sdkVersion. Valid options are ${(_lodash || _load_lodash()).default.keys(sdkVersions).join(', ')}`, 'doctor-invalid-sdk-version');
      return ERROR;
    }
    (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-invalid-sdk-version');

    const reactNativeIssue = yield _validateReactNativeVersionAsync(exp, pkg, projectRoot, sdkVersions, sdkVersion);

    if (reactNativeIssue !== NO_ISSUES) {
      return reactNativeIssue;
    }

    // TODO: Check any native module versions here

    return NO_ISSUES;
  });

  return function _validateExpJsonAsync(_x14, _x15, _x16, _x17) {
    return _ref6.apply(this, arguments);
  };
})();

let _validateReactNativeVersionAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (exp, pkg, projectRoot, sdkVersions, sdkVersion) {
    if ((_Config || _load_Config()).default.validation.reactNativeVersionWarnings) {
      let reactNative = pkg.dependencies['react-native'];

      if (!reactNative.match(/expo\/react-native/)) {
        return NO_ISSUES;

        // (TODO-2017-07-20): Validate the react-native version if it uses
        // officially published package rather than Expo fork. Expo fork of
        // react-native was required before CRNA. We now only run the react-native
        // validation of the version if we are using the fork. We should probably
        // validate the version here as well such that it matches with the
        // react-native version compatible with the selected SDK.
        //
        // ProjectUtils.logWarning(
        //   projectRoot,
        //   'expo',
        //   `Warning: Not using the Expo fork of react-native. See ${Config.helpUrl}.`,
        //   'doctor-not-using-expo-fork'
        // );
        // return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-not-using-expo-fork');

      try {
        let reactNativeTag = reactNative.match(/sdk-\d+\.\d+\.\d+/)[0];
        let sdkVersionObject = sdkVersions[sdkVersion];

        // TODO: Want to be smarter about this. Maybe warn if there's a newer version.
        if ((_semver || _load_semver()).default.major((_Versions || _load_Versions()).parseSdkVersionFromTag(reactNativeTag)) !== (_semver || _load_semver()).default.major((_Versions || _load_Versions()).parseSdkVersionFromTag(sdkVersionObject['expoReactNativeTag']))) {
          (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: Invalid version of react-native for sdkVersion ${sdkVersion}. Use github:expo/react-native#${sdkVersionObject['expoReactNativeTag']}`, 'doctor-invalid-version-of-react-native');
          return WARNING;
        }
        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-invalid-version-of-react-native');

        (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-malformed-version-of-react-native');
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Warning: ${reactNative} is not a valid version. Version must be in the form of sdk-x.y.z. Please update your package.json file.`, 'doctor-malformed-version-of-react-native');
        return WARNING;
      }
    }

    return NO_ISSUES;
  });

  return function _validateReactNativeVersionAsync(_x18, _x19, _x20, _x21, _x22) {
    return _ref7.apply(this, arguments);
  };
})();

// TODO: use `yarn check`


let _validateNodeModulesAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (projectRoot) {
    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);
    let nodeModulesPath = projectRoot;
    if (exp.nodeModulesPath) {
      nodeModulesPath = _path.default.join(projectRoot, exp.nodeModulesPath);
    }

    // Check to make sure node_modules exists at all
    try {
      let result = (_fsExtra || _load_fsExtra()).default.statSync(_path.default.join(nodeModulesPath, 'node_modules'));
      if (!result.isDirectory()) {
        (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: node_modules directory is missing. Please run \`npm install\` in your project directory.`, 'doctor-node-modules-missing');
        return FATAL;
      }

      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-node-modules-missing');
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: node_modules directory is missing. Please run \`npm install\` in your project directory.`, 'doctor-node-modules-missing');
      return FATAL;
    }

    // Check to make sure react native is installed
    try {
      let result = (_fsExtra || _load_fsExtra()).default.statSync(_path.default.join(nodeModulesPath, 'node_modules', 'react-native', 'local-cli', 'cli.js'));
      if (!result.isFile()) {
        (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: React native is not installed. Please run \`npm install\` in your project directory.`, 'doctor-react-native-not-installed');
        return FATAL;
      }

      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-react-native-not-installed');
    } catch (e) {
      (_ProjectUtils || _load_ProjectUtils()).logError(projectRoot, 'expo', `Error: React native is not installed. Please run \`npm install\` in your project directory.`, 'doctor-react-native-not-installed');
      return FATAL;
    }

    // Validate all package.json dependencies are installed and up to date
    if (pkg.dependencies) {
      yield (_Binaries || _load_Binaries()).sourceBashLoginScriptsAsync();

      try {
        yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['--version']);
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `\`npm\` command not found. If you have npm installed please run \`npm install -g exp && exp path\`.`, 'doctor-npm-not-found');
        return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-npm-not-found');

      let npmls;
      try {
        let npmlsCommand = yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['ls', '--json', '--depth', '1'], {
          cwd: nodeModulesPath
        });
        npmls = npmlsCommand.stdout;
        if (npmlsCommand.signal === 'SIGINT') {
          // The child process was interrupted (e.g. the user pressed ^C),
          // let's not spam the console with warnings about that.
          return NO_ISSUES;
        }
      } catch (e) {
        npmls = e.stdout; // `npm ls` sometimes returns an error code
        if (e.signal === 'SIGINT') {
          // The child process was interrupted (e.g. the user pressed ^C),
          // let's not spam the console with warnings about that.
          return NO_ISSUES;
        }
      }

      if (!npmls) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Problem checking node_modules dependencies. Could not run \`npm ls\` in ${projectRoot}.`, 'doctor-could-not-run-npm-ls');
        return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-could-not-run-npm-ls');

      let npmlsDependencies;
      try {
        npmlsDependencies = JSON.parse(npmls).dependencies;
      } catch (e) {
        (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', `Problem checking node_modules dependencies: ${e.message}`, 'doctor-problem-checking-node-modules');
        return WARNING;
      }
      (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-problem-checking-node-modules');

      if (npmlsDependencies) {
        let errorStrings = [];
        (_lodash || _load_lodash()).default.forEach(pkg.dependencies, function (versionRequired, dependency) {
          let installedDependency = npmlsDependencies[dependency];
          if (dependency === 'react' && versionRequired.match(/-(alpha|beta|rc)/)) {
            // ignore prerelease dependencies on react
          } else if (!installedDependency || !installedDependency.version) {
            if (installedDependency && installedDependency.peerMissing) {
              errorStrings.push(`Warning: '${dependency}' peer dependency missing. Run \`npm ls\` in ${nodeModulesPath} to see full warning.`);
            } else {
              errorStrings.push(`Warning: '${dependency}' dependency is not installed.`);
            }
          } else if (dependency === 'expo' && exp.sdkVersion !== 'UNVERSIONED' && (_semver || _load_semver()).default.major(installedDependency.version) !== (_semver || _load_semver()).default.major(exp.sdkVersion)) {
            // Warn user if versions are not aligned
            errorStrings.push('Warning: Expo version in package.json does not match sdkVersion in manifest.');
          } else if (dependency !== 'react-native' && !(_semver || _load_semver()).default.satisfies(installedDependency.version, versionRequired) && !versionRequired.includes(installedDependency.from)) {
            // TODO: also check react-native
            // For react native, `from` field looks like "expo/react-native#sdk-8.0.1" and
            // versionRequired looks like "github:expo/react-native#sdk-8.0.0"
            errorStrings.push(`Warning: Installed version ${installedDependency.version} of '${dependency}' does not satisfy required version ${versionRequired}`);
          }
        });

        if (errorStrings.length > 0) {
          errorStrings.push(`\nIf there is an issue running your project, please run \`npm install\` in ${nodeModulesPath} and restart.`);
          (_ProjectUtils || _load_ProjectUtils()).logWarning(projectRoot, 'expo', errorStrings.join('\n'), 'doctor-node-modules-issues');
          return WARNING;
        } else {
          (_ProjectUtils || _load_ProjectUtils()).clearNotification(projectRoot, 'doctor-node-modules-issues');
        }
      }
    }

    return NO_ISSUES;
  });

  return function _validateNodeModulesAsync(_x23) {
    return _ref8.apply(this, arguments);
  };
})();

let validateLowLatencyAsync = exports.validateLowLatencyAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (projectRoot) {
    return validateAsync(projectRoot, false);
  });

  return function validateLowLatencyAsync(_x24) {
    return _ref9.apply(this, arguments);
  };
})();

let validateWithNetworkAsync = exports.validateWithNetworkAsync = (() => {
  var _ref10 = _asyncToGenerator(function* (projectRoot) {
    return validateAsync(projectRoot, true);
  });

  return function validateWithNetworkAsync(_x25) {
    return _ref10.apply(this, arguments);
  };
})();

let validateAsync = (() => {
  var _ref11 = _asyncToGenerator(function* (projectRoot, allowNetwork) {
    if ((_getenv || _load_getenv()).default.boolish('EXPO_NO_DOCTOR', false)) {
      return NO_ISSUES;
    }

    let { exp, pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);

    let status = yield _checkNpmVersionAsync(projectRoot);
    if (status === FATAL) {
      return status;
    }

    const expStatus = yield _validateExpJsonAsync(exp, pkg, projectRoot, allowNetwork);
    if (expStatus === FATAL) {
      return expStatus;
    }

    const packageStatus = yield _validatePackageJsonAsync(exp, pkg, projectRoot);

    status = Math.max(status, expStatus, packageStatus);
    if (status === FATAL) return status;

    // TODO: this broke once we started using yarn because `npm ls` doesn't
    // work on a yarn install. Use `yarn check` in the future.
    if (status !== FATAL && exp && !exp.ignoreNodeModulesValidation) {
      let nodeModulesStatus = yield _validateNodeModulesAsync(projectRoot);
      if (nodeModulesStatus > status) {
        return nodeModulesStatus;
      }
    }

    return status;
  });

  return function validateAsync(_x26, _x27) {
    return _ref11.apply(this, arguments);
  };
})();

let getExpoSdkStatus = exports.getExpoSdkStatus = (() => {
  var _ref12 = _asyncToGenerator(function* (projectRoot) {
    let { pkg } = yield (_ProjectUtils || _load_ProjectUtils()).readConfigJsonAsync(projectRoot);

    try {
      let sdkPkg;
      if (pkg.dependencies['exponent']) {
        sdkPkg = 'exponent';
      } else if (pkg.dependencies['expo']) {
        sdkPkg = 'expo';
      } else {
        return EXPO_SDK_NOT_INSTALLED;
      }

      let mainFilePath = _path.default.join(projectRoot, pkg.main);
      let mainFile = yield (_fsExtra || _load_fsExtra()).default.readFile(mainFilePath, 'utf8');

      // TODO: support separate .ios.js and .android.js files
      if (mainFile.includes(`from '${sdkPkg}'`) || mainFile.includes(`require('${sdkPkg}')`)) {
        return EXPO_SDK_INSTALLED_AND_IMPORTED;
      } else {
        return EXPO_SDK_NOT_IMPORTED;
      }
    } catch (e) {
      return EXPO_SDK_NOT_IMPORTED;
    }
  });

  return function getExpoSdkStatus(_x28) {
    return _ref12.apply(this, arguments);
  };
})();

var _lodash;

function _load_lodash() {
  return _lodash = _interopRequireDefault(require('lodash'));
}

var _semver;

function _load_semver() {
  return _semver = _interopRequireDefault(require('semver'));
}

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _getenv;

function _load_getenv() {
  return _getenv = _interopRequireDefault(require('getenv'));
}

var _path = _interopRequireDefault(require('path'));

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@expo/spawn-async'));
}

var _schemer;

function _load_schemer() {
  return _schemer = _interopRequireDefault(require('@expo/schemer'));
}

var _schemer2;

function _load_schemer2() {
  return _schemer2 = require('@expo/schemer');
}

var _ExpSchema;

function _load_ExpSchema() {
  return _ExpSchema = _interopRequireWildcard(require('./ExpSchema'));
}

var _ProjectUtils;

function _load_ProjectUtils() {
  return _ProjectUtils = _interopRequireWildcard(require('./ProjectUtils'));
}

var _Api;

function _load_Api() {
  return _Api = _interopRequireDefault(require('../Api'));
}

var _Binaries;

function _load_Binaries() {
  return _Binaries = _interopRequireWildcard(require('../Binaries'));
}

var _Config;

function _load_Config() {
  return _Config = _interopRequireDefault(require('../Config'));
}

var _Versions;

function _load_Versions() {
  return _Versions = _interopRequireWildcard(require('../Versions'));
}

var _Watchman;

function _load_Watchman() {
  return _Watchman = _interopRequireWildcard(require('../Watchman'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const NO_ISSUES = exports.NO_ISSUES = 0;
const WARNING = exports.WARNING = 1;
const ERROR = exports.ERROR = 2;
const FATAL = exports.FATAL = 3;

const MIN_WATCHMAN_VERSION = '4.6.0';
const MIN_NPM_VERSION = '3.0.0';
const CORRECT_NPM_VERSION = '4.6.1';
const WARN_NPM_VERSION_RANGES = ['>= 5.0.0'];
const BAD_NPM_VERSION_RANGES = ['>= 5.0.0 <= 5.0.3'];

function _isNpmVersionWithinRanges(npmVersion, ranges) {
  return (_lodash || _load_lodash()).default.some(ranges, range => (_semver || _load_semver()).default.satisfies(npmVersion, range));
}

function formatValidationError(validationError) {
  return `\n • ${validationError.fieldPath ? 'Field: ' + validationError.fieldPath + ' - ' : ''}${validationError.message}.`;
}

const EXPO_SDK_INSTALLED_AND_IMPORTED = exports.EXPO_SDK_INSTALLED_AND_IMPORTED = 0;
const EXPO_SDK_NOT_INSTALLED = exports.EXPO_SDK_NOT_INSTALLED = 1;
const EXPO_SDK_NOT_IMPORTED = exports.EXPO_SDK_NOT_IMPORTED = 2;
//# sourceMappingURL=../__sourcemaps__/project/Doctor.js.map
