'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let installAndInstructAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (projectDir, unsupportedPackagesUsed) {
    let nodeModulesPath = _path.default.join(projectDir, '/node_modules');
    let nextStepMessagePath = _path.default.join(projectDir, '/expo-next-steps.txt');

    (_fsExtra || _load_fsExtra()).default.removeSync(nodeModulesPath);
    console.log('Running npm install, this may take a few minutes.');
    console.log('-----------------------------------------------------');
    let npmInstallError = false;
    try {
      yield (0, (_spawnAsync || _load_spawnAsync()).default)('npm', ['install'], { cwd: projectDir, stdio: 'inherit' });
    } catch (e) {
      console.log('\n');
      npmInstallError = true;
    }
    console.log('\n');
    console.log('#####################################################');
    console.log('             npm install complete');
    console.log('#####################################################');

    if (npmInstallError) {
      console.log('\n');
      console.log('* There was an error though, please read the error message, try to fix the issue and then run npm install again. No need to run exp convert again.');
    }

    console.log('\n');
    const nextStepMessage = `Next steps:
------------
1. If you have separate index.ios.js and index.android.js files, you'll need to create a main.js file that contains \`require('./index');\`. Also set \`"main": "main.js"\` in package.json.
2. Find your AppRegistry.registerComponent('YourApplicationName', () => YourRootComponent) call and replace it with Expo.registerRootComponent(YourRootComponent) (you will need to import Expo from 'expo').
3. Upload your app icon somewhere on the web and add it the newly created exp.json file, in the iconUrl and loading.iconUrl fields.
4. Delete your 'android' and 'ios' directories if you have them -- you no longer need to compile any native code to run your app.
5. ${showCompatibilityMessage(unsupportedPackagesUsed)}
6. Open your app in XDE and run it, fix bugs as they arise.
`;
    console.log(nextStepMessage);
    (_fsExtra || _load_fsExtra()).default.outputFileSync(nextStepMessagePath, nextStepMessage);
    console.log('(This message has been saved to expo-next-steps.txt for your convenience)');
  });

  return function installAndInstructAsync(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
})();

var _slugify;

function _load_slugify() {
  return _slugify = _interopRequireDefault(require('slugify'));
}

var _path = _interopRequireDefault(require('path'));

var _jsonfile;

function _load_jsonfile() {
  return _jsonfile = _interopRequireDefault(require('jsonfile'));
}

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@expo/spawn-async'));
}

var _exp;

function _load_exp() {
  return _exp = _interopRequireDefault(require('./templates/exp'));
}

var _babelrc;

function _load_babelrc() {
  return _babelrc = _interopRequireDefault(require('./templates/babelrc'));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = (() => {
  var _ref = _asyncToGenerator(function* (projectDir, { projectName, projectDescription, projectEntryPoint }) {
    let projectSlug = (0, (_slugify || _load_slugify()).default)(projectName.toLowerCase());

    let expJsonTargetPath = _path.default.join(projectDir, '/exp.json');
    let babelRcTargetPath = _path.default.join(projectDir, '/.babelrc');

    let packageJsonSourcePath = _path.default.join(projectDir, '/package.json');
    let packageJsonTargetPath = _path.default.join(projectDir, '/package.json');

    // Add values to exp.json, save to given path
    let expJson = _extends({}, (_exp || _load_exp()).default);
    expJson.name = projectName;
    expJson.description = projectDescription || 'No description';
    expJson.slug = projectSlug;
    (_jsonfile || _load_jsonfile()).default.writeFileSync(expJsonTargetPath, expJson, { spaces: 2 });
    console.log('Wrote exp.json');

    // Add entry point and dependencies to package.json
    let unsupportedPackagesUsed = [];
    let packageJson = (_jsonfile || _load_jsonfile()).default.readFileSync(packageJsonSourcePath);
    packageJson.dependencies = _extends({}, packageJson.dependencies, dependencies);

    // Remove
    Object.keys(packageJson.dependencies).forEach(function (dep) {
      if (unsupportedPackages[dep]) {
        delete packageJson.dependencies[dep];
        unsupportedPackagesUsed.push(dep);
      }
    });

    // TODO: we don't actually support index.android.js and index.ios.js right now!
    if (projectEntryPoint !== 'index.*.js' && projectEntryPoint !== 'index.js' && projectEntryPoint !== 'index.ios.js' && projectEntryPoint !== 'index.android.js') {
      packageJson.main = projectEntryPoint;
    }
    (_jsonfile || _load_jsonfile()).default.writeFileSync(packageJsonTargetPath, packageJson, { spaces: 2 });
    console.log('Updated package.json');

    // TODO: Add import Expo from 'expo'; at the top of main file
    // TODO: Add .expo/* to gitignore

    // Copy babelrc
    (_jsonfile || _load_jsonfile()).default.writeFileSync(babelRcTargetPath, (_babelrc || _load_babelrc()).default, { spaces: 2 });
    console.log('Updated .babelrc');

    // Save next steps to a file, display, exit
    yield installAndInstructAsync(projectDir, unsupportedPackagesUsed);
  });

  function convertProjectAsync(_x, _x2) {
    return _ref.apply(this, arguments);
  }

  return convertProjectAsync;
})();

const dependencies = {
  '@expo/vector-icons': '~4.0.0',
  expo: '~15.0.0',
  react: '~15.4.2',
  'react-native': 'github:exponent/react-native#sdk-15.0.0'
};

const unsupportedPackages = {
  'react-native-video': `Expo provides a video component for you with the same API as react-native-video. You can use it with "import { Components } from 'expo';" and <Components.Video /> in your render function. `,
  'react-native-svg': `Expo provides react-native-svg for you. You can use it with "import { Components } from 'expo';" and <Components.Svg /> in your render function.`,
  'react-native-maps': `Expo provides react-native-maps for you. You can use it with "import { Components } from 'expo';" and <Components.Map /> in your render function.`,
  'react-native-linear-gradient': `Expo provides react-native-linear-gradient for you. You can use it with "import { Components } from 'expo';" and <Components.LinearGradient /> in your render function.`
};

function showCompatibilityMessage(packages) {
  if (packages.length) {
    return `Resolve any issues with potentially incompatible packages: \n\n` + packages.map(pkg => {
      return `** ${pkg}: ${unsupportedPackages[pkg]}`;
    }).join('\n') + `\n** This may not be an exhaustive list of packages you will need to address -- any package that has a native code dependency will need to be converted to an Expo equivalent or removed. Refer to the SDK API reference here: https://docs.expo.io/versions/latest/sdk/index.html`;
  } else {
    return `We didn't detect any known incompatible packages, but if you have any with native dependencies installed, you will need to remove them from your project.`;
  }
}
//# sourceMappingURL=../__sourcemaps__/project/Convert.js.map
