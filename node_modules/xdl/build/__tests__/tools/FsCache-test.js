'use strict';

var _FsCache;

function _load_FsCache() {
  return _FsCache = require('../../tools/FsCache');
}

var _Config;

function _load_Config() {
  return _Config = _interopRequireDefault(require('../../Config'));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

jest.mock('analytics-node');

const fsp = require('mz/fs');
const path = require('path');
const pathExists = require('path-exists');

describe('Cacher', () => {
  it('works without a bootstrap file', _asyncToGenerator(function* () {
    const dateCacher = new (_FsCache || _load_FsCache()).Cacher(_asyncToGenerator(function* () {
      return new Date();
    }), 'dateslol', 1000);

    try {
      yield dateCacher.clearAsync();
    } catch (e) {
      // this is ok
    }

    const date1 = new Date((yield dateCacher.getAsync()));

    // should be well within the TTL, should be identical value
    expect(date1).toEqual(new Date((yield dateCacher.getAsync())));

    // should be outside of the TTL -- just making sure that sufficient delay will change the value
    setTimeout(function () {
      dateCacher.getAsync().then(function (d) {
        expect(date1).not.toEqual(new Date(d));
      });
    }, 3000);
  }));

  it('works with a bootstrap file', _asyncToGenerator(function* () {
    const expected = JSON.parse((yield fsp.readFile(path.join(__dirname, '../../../package.json'))));

    const failCacher = new (_FsCache || _load_FsCache()).Cacher(function () {
      throw new Error('lol this never succeeds');
    }, 'bootstrap', 1000, path.join(__dirname, '../../../package.json'));

    // since we don't mock the fs here (.cache is transient), need to make sure it's empty
    try {
      yield failCacher.clearAsync();
    } catch (e) {
      // noop
    }

    const found = yield failCacher.getAsync();

    expect(found).toEqual(expected);
  }));
});
//# sourceMappingURL=../../__sourcemaps__/__tests__/tools/FsCache-test.js.map
