// Copyright 2015-present 650 Industries. All rights reserved.

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIOSShellAppAsync = undefined;

/**
 *  Build the iOS workspace at the given path.
 *  @return the path to the resulting build artifact
 */
let _buildAsync = (() => {
  var _ref = _asyncToGenerator(function* (projectName, workspacePath, configuration, type, relativeBuildDestination, verbose) {
    let buildCmd, pathToArtifact;
    const buildDest = `${relativeBuildDestination}-${type}`;
    if (type === 'simulator') {
      buildCmd = `xcodebuild -workspace ${projectName}.xcworkspace -scheme ${projectName} -sdk iphonesimulator -configuration ${configuration} -derivedDataPath ${buildDest} CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO ARCHS="i386 x86_64" ONLY_ACTIVE_ARCH=NO | xcpretty`;
      pathToArtifact = _path.default.join(buildDest, 'Build', 'Products', `${configuration}-iphonesimulator`, `${projectName}.app`);
    } else if (type === 'archive') {
      buildCmd = `xcodebuild -workspace ${projectName}.xcworkspace -scheme ${projectName} -sdk iphoneos -destination generic/platform=iOS -configuration ${configuration} archive -derivedDataPath ${buildDest} -archivePath ${buildDest}/${projectName}.xcarchive CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO | xcpretty`;
      pathToArtifact = _path.default.join(buildDest, `${projectName}.xcarchive`);
    } else {
      throw new Error(`Unsupported build type: ${type}`);
    }

    console.log(`Building iOS workspace at ${workspacePath} to ${buildDest}:\n`);
    console.log(buildCmd);
    if (!verbose) {
      console.log('\nxcodebuild is running. Logging errors only. To see full output, use --verbose 1...');
    }
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)(buildCmd, null, {
      // only stderr
      stdio: verbose ? 'inherit' : ['ignore', 'ignore', 'inherit'],
      cwd: workspacePath,
      shell: true
    });
    return _path.default.resolve(workspacePath, pathToArtifact);
  });

  return function _buildAsync(_x, _x2, _x3, _x4, _x5, _x6) {
    return _ref.apply(this, arguments);
  };
})();

let _podInstallAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (workspacePath, isRepoUpdateEnabled) {
    // ensure pods are clean
    const pathsToClean = [_path.default.join(workspacePath, 'Pods'), _path.default.join(workspacePath, 'Podfile.lock')];
    pathsToClean.forEach(function (path) {
      if ((_fsExtra || _load_fsExtra()).default.existsSync(path)) {
        (_rimraf || _load_rimraf()).default.sync(path);
      }
    });

    // install
    let cocoapodsArgs = ['install'];
    if (isRepoUpdateEnabled) {
      cocoapodsArgs.push('--repo-update');
    }
    console.log('Installing iOS workspace dependencies...');
    console.log(`pod ${cocoapodsArgs.join(' ')}`);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('pod', cocoapodsArgs, {
      stdio: 'inherit',
      cwd: workspacePath
    });
  });

  return function _podInstallAsync(_x7, _x8) {
    return _ref2.apply(this, arguments);
  };
})();

let _createStandaloneContextAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (args) {
    // right now we only ever build a single detached workspace for service contexts.
    // TODO: support multiple different pod configurations, assemble a cache of those builds.
    const expoSourcePath = '../ios';
    const workspaceSourcePath = _path.default.join(expoSourcePath, '..', 'shellAppWorkspaces', 'ios', 'default');
    let { privateConfigFile } = args;

    let privateConfig;
    if (privateConfigFile) {
      let privateConfigContents = yield (_fsExtra || _load_fsExtra()).default.readFile(privateConfigFile, 'utf8');
      privateConfig = JSON.parse(privateConfigContents);
    }

    let manifest;
    if (args.action === 'configure') {
      const { url, sdkVersion, releaseChannel } = args;
      manifest = yield (0, (_ExponentTools || _load_ExponentTools()).getManifestAsync)(url, {
        'Exponent-SDK-Version': sdkVersion,
        'Exponent-Platform': 'ios',
        'Expo-Release-Channel': releaseChannel ? releaseChannel : 'default'
      });
    }

    const buildFlags = (_StandaloneBuildFlags || _load_StandaloneBuildFlags()).default.createIos(args.configuration, {
      workspaceSourcePath,
      appleTeamId: args.appleTeamId
    });
    const context = (_StandaloneContext || _load_StandaloneContext()).default.createServiceContext(expoSourcePath, args.archivePath, manifest, privateConfig, buildFlags, args.url, args.releaseChannel);
    return context;
  });

  return function _createStandaloneContextAsync(_x9) {
    return _ref3.apply(this, arguments);
  };
})();

/**
 * possible args:
 *  @param url manifest url for shell experience
 *  @param sdkVersion sdk to use when requesting the manifest
 *  @param releaseChannel channel to pull manifests from, default is 'default'
 *  @param archivePath path to existing NSBundle to configure
 *  @param privateConfigFile path to a private config file containing, e.g., private api keys
 *  @param appleTeamId Apple Developer's account Team ID
 *  @param output specify the output path of the configured archive (ie) /tmp/my-app-archive-build.xcarchive or /tmp/my-app-ios-build.tar.gz
*/


let _configureAndCopyShellAppArchiveAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (args) {
    const { output, type } = args;
    const context = yield _createStandaloneContextAsync(args);
    const { projectName } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);

    yield (_IosNSBundle || _load_IosNSBundle()).configureAsync(context);
    if (output) {
      // TODO: un-hard-code ExpoKitApp.app
      const archiveName = projectName.replace(/[^0-9a-z_\-\.]/gi, '_');
      const appReleasePath = _path.default.resolve(_path.default.join(`${context.data.archivePath}`, '..'));
      if (type === 'simulator') {
        yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)(`mv ExpoKitApp.app ${archiveName}.app && tar -czvf ${output} ${archiveName}.app`, null, {
          stdio: 'inherit',
          cwd: appReleasePath,
          shell: true
        });
      } else if (type === 'archive') {
        yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsync)('/bin/mv', [`ExpoKitApp.xcarchive`, output], {
          stdio: 'inherit',
          cwd: `${context.data.archivePath}/../../../..`
        });
      }
    }
  });

  return function _configureAndCopyShellAppArchiveAsync(_x10) {
    return _ref4.apply(this, arguments);
  };
})();

let _createShellAppWorkspaceAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (context, skipRepoUpdate) {
    if ((_fsExtra || _load_fsExtra()).default.existsSync(context.build.ios.workspaceSourcePath)) {
      console.log(`Removing existing workspace at ${context.build.ios.workspaceSourcePath}...`);
      try {
        (_rimraf || _load_rimraf()).default.sync(context.build.ios.workspaceSourcePath);
      } catch (_) {}
    }
    yield (_IosWorkspace || _load_IosWorkspace()).createDetachedAsync(context);
    yield _podInstallAsync(context.build.ios.workspaceSourcePath, !skipRepoUpdate);
  });

  return function _createShellAppWorkspaceAsync(_x11, _x12) {
    return _ref5.apply(this, arguments);
  };
})();

/**
 * possible args:
 *  @param configuration StandaloneBuildConfiguration (Debug or Release)
 *  @param verbose show all xcodebuild output (default false)
 *  @param reuseWorkspace if true, when building, assume a detached workspace already exists rather than creating a new one.
 *  @param skipRepoUpdate if true, when building, omit `--repo-update` cocoapods flag.
 */


let _buildAndCopyShellAppArtifactAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (args) {
    const context = yield _createStandaloneContextAsync(args);
    const { verbose, type, reuseWorkspace } = args;
    const { projectName } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);

    if (!reuseWorkspace) {
      yield _createShellAppWorkspaceAsync(context, args.skipRepoUpdate);
    }
    const pathToArtifact = yield _buildAsync(projectName, context.build.ios.workspaceSourcePath, context.build.configuration, type, _path.default.relative(context.build.ios.workspaceSourcePath, '../shellAppBase'), verbose);
    const artifactDestPath = _path.default.join('../shellAppBase-builds', type, context.build.configuration);
    console.log(`\nFinished building, copying artifact to ${_path.default.resolve(artifactDestPath)}...`);
    if ((_fsExtra || _load_fsExtra()).default.existsSync(artifactDestPath)) {
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/rm', ['-rf', artifactDestPath]);
    }
    console.log(`mkdir -p ${artifactDestPath}`);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/mkdir', ['-p', artifactDestPath]);
    console.log(`cp -R ${pathToArtifact} ${artifactDestPath}`);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/cp', ['-R', pathToArtifact, artifactDestPath]);
  });

  return function _buildAndCopyShellAppArtifactAsync(_x13) {
    return _ref6.apply(this, arguments);
  };
})();

/**
 *  possible args in addition to action-specific args:
 *  @param action
 *    build - build a binary
 *    configure - don't build anything, just configure the files in an existing NSBundle
 *  @param type type of artifact to build or configure (simulator or archive)
 */


let createIOSShellAppAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (args) {
    args = _validateCLIArgs(args);
    if (args.action === 'build') {
      yield _buildAndCopyShellAppArtifactAsync(args);
    } else if (args.action === 'configure') {
      yield _configureAndCopyShellAppArchiveAsync(args);
    }
  });

  return function createIOSShellAppAsync(_x14) {
    return _ref7.apply(this, arguments);
  };
})();

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _path = _interopRequireDefault(require('path'));

var _rimraf;

function _load_rimraf() {
  return _rimraf = _interopRequireDefault(require('rimraf'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _IosNSBundle;

function _load_IosNSBundle() {
  return _IosNSBundle = _interopRequireWildcard(require('./IosNSBundle'));
}

var _IosWorkspace;

function _load_IosWorkspace() {
  return _IosWorkspace = _interopRequireWildcard(require('./IosWorkspace'));
}

var _StandaloneBuildFlags;

function _load_StandaloneBuildFlags() {
  return _StandaloneBuildFlags = _interopRequireDefault(require('./StandaloneBuildFlags'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _validateCLIArgs(args) {
  args.type = args.type || 'archive';
  args.configuration = args.configuration || 'Release';
  args.verbose = args.verbose || false;

  switch (args.type) {
    case 'simulator':
      {
        if (args.configuration !== 'Debug' && args.configuration !== 'Release') {
          throw new Error(`Unsupported build configuration ${args.configuration}`);
        }
        break;
      }
    case 'archive':
      {
        if (args.configuration !== 'Release') {
          throw new Error('Release is the only supported configuration when archiving');
        }
        break;
      }
    default:
      {
        throw new Error(`Unsupported build type ${args.type}`);
      }
  }

  switch (args.action) {
    case 'configure':
      {
        if (!args.url) {
          throw new Error('Must run with `--url MANIFEST_URL`');
        }
        if (!args.sdkVersion) {
          throw new Error('Must run with `--sdkVersion SDK_VERSION`');
        }
        if (!args.archivePath) {
          throw new Error('Need to provide --archivePath <path to existing archive for configuration>');
        }
        break;
      }
    case 'build':
      {
        break;
      }
    default:
      {
        throw new Error(`Unsupported build action ${args.action}`);
      }
  }

  return args;
}exports.createIOSShellAppAsync = createIOSShellAppAsync;
//# sourceMappingURL=../__sourcemaps__/detach/IosShellApp.js.map
