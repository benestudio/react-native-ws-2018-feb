'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureLaunchAssetsAsync = undefined;

let _saveImageAssetsAsync = (() => {
  var _ref = _asyncToGenerator(function* (context) {
    let tabletImagePathOrUrl, phoneImagePathOrUrl;

    if (context.type === 'user') {
      // copy images from local project
      const exp = context.data.exp;
      if (exp.ios && exp.ios.splash && exp.ios.splash.image) {
        phoneImagePathOrUrl = exp.ios.splash.image;

        if (exp.ios.splash.tabletImage) {
          tabletImagePathOrUrl = exp.ios.splash.tabletImage;
        }
      } else if (exp.splash && exp.splash.image) {
        phoneImagePathOrUrl = exp.splash.image;
      }
    } else {
      // use uploaded assets from published project
      const manifest = context.data.manifest;
      if (manifest.ios && manifest.ios.splash && manifest.ios.splash.imageUrl) {
        phoneImagePathOrUrl = manifest.ios.splash.imageUrl;

        if (manifest.ios.splash.tabletImageUrl) {
          tabletImagePathOrUrl = manifest.ios.splash.tabletImageUrl;
        }
      } else if (manifest.splash && manifest.splash.imageUrl) {
        phoneImagePathOrUrl = manifest.splash.imageUrl;
      }
    }

    if (!phoneImagePathOrUrl) {
      return;
    }

    const outputs = [];
    if (!tabletImagePathOrUrl) {
      outputs.push({
        pathOrUrl: phoneImagePathOrUrl,
        filename: 'launch_background_image.png'
      });
    } else {
      outputs.push({
        pathOrUrl: phoneImagePathOrUrl,
        filename: 'launch_background_image~iphone.png'
      });
      outputs.push({
        pathOrUrl: tabletImagePathOrUrl,
        filename: 'launch_background_image.png'
      });
    }

    const { supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
    const projectRoot = context.type === 'user' ? context.data.projectPath : supportingDirectory;
    outputs.forEach((() => {
      var _ref2 = _asyncToGenerator(function* (output) {
        const { pathOrUrl, filename } = output;
        const destinationPath = _path.default.join(supportingDirectory, filename);
        yield (0, (_ExponentTools || _load_ExponentTools()).saveImageToPathAsync)(projectRoot, pathOrUrl, destinationPath);
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    })());
  });

  return function _saveImageAssetsAsync(_x) {
    return _ref.apply(this, arguments);
  };
})();

let _copyIntermediateLaunchScreenAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (context, launchScreenPath) {
    let splashTemplateFilename;
    if (context.type === 'user') {
      const { supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
      splashTemplateFilename = _path.default.join(supportingDirectory, 'LaunchScreen.xib');
    } else {
      // TODO: after shell apps use detached workspaces,
      // we can just do this with the workspace's copy instead of referencing expoSourcePath.
      const expoTemplatePath = _path.default.join(context.data.expoSourcePath, '..', 'exponent-view-template', 'ios');
      splashTemplateFilename = _path.default.join(expoTemplatePath, 'exponent-view-template', 'Supporting', 'LaunchScreen.xib');
    }
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/cp', [splashTemplateFilename, launchScreenPath], {
      stdio: 'inherit'
    });
    return;
  });

  return function _copyIntermediateLaunchScreenAsync(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
})();

let configureLaunchAssetsAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (context, intermediatesDirectory) {
    if (_maybeAbortForBackwardsCompatibility(context)) {
      return;
    }
    console.log('Configuring iOS Launch Screen...');

    (_mkdirp || _load_mkdirp()).default.sync(intermediatesDirectory);
    const { supportingDirectory } = (_IosWorkspace || _load_IosWorkspace()).getPaths(context);
    const config = context.config;

    const splashIntermediateFilename = _path.default.join(intermediatesDirectory, 'LaunchScreen.xib');
    yield _copyIntermediateLaunchScreenAsync(context, splashIntermediateFilename);

    if ((0, (_ExponentTools || _load_ExponentTools()).manifestUsesSplashApi)(config, 'ios')) {
      yield (0, (_ExponentTools || _load_ExponentTools()).transformFileContentsAsync)(splashIntermediateFilename, function (fileString) {
        const parser = new (_xmldom || _load_xmldom()).DOMParser();
        const serializer = new (_xmldom || _load_xmldom()).XMLSerializer();
        const dom = parser.parseFromString(fileString);

        _setBackgroundColor(config, dom);
        _setBackgroundImageResizeMode(config, dom);

        return serializer.serializeToString(dom);
      });

      yield _saveImageAssetsAsync(context);
    }

    if (context.type === 'user') {
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/cp', [splashIntermediateFilename, _path.default.join(supportingDirectory, 'LaunchScreen.xib')], {
        stdio: 'inherit'
      });
    } else {
      const splashOutputFilename = _path.default.join(supportingDirectory, 'Base.lproj', 'LaunchScreen.nib');
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('ibtool', ['--compile', splashOutputFilename, splashIntermediateFilename]);
    }
    return;
  });

  return function configureLaunchAssetsAsync(_x5, _x6) {
    return _ref4.apply(this, arguments);
  };
})();

var _mkdirp;

function _load_mkdirp() {
  return _mkdirp = _interopRequireDefault(require('mkdirp'));
}

var _path = _interopRequireDefault(require('path'));

var _xmldom;

function _load_xmldom() {
  return _xmldom = require('xmldom');
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('./ExponentTools');
}

var _IosWorkspace;

function _load_IosWorkspace() {
  return _IosWorkspace = _interopRequireWildcard(require('./IosWorkspace'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const ASPECT_FILL = 'scaleAspectFill';
const ASPECT_FIT = 'scaleAspectFit';

const backgroundImageViewID = 'Bsh-cT-K4l';
const backgroundViewID = 'OfY-5Y-tS4';

function _backgroundColorFromHexString(hexColor) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColor);
  if (!result || result.length < 4) {
    // Default to white if we can't parse the color. We should have 3 matches.
    console.warn('Unable to parse color: ', hexColor, ' result:', result);
    return { r: 1, g: 1, b: 1 };
  }

  const r = parseInt(result[1], 16) / 255;
  const g = parseInt(result[2], 16) / 255;
  const b = parseInt(result[3], 16) / 255;
  return { r, g, b };
}

function _setBackgroundColor(manifest, dom) {
  let backgroundColorString;
  if (manifest.ios && manifest.ios.splash && manifest.ios.splash.backgroundColor) {
    backgroundColorString = manifest.ios.splash.backgroundColor;
  } else if (manifest.splash && manifest.splash.backgroundColor) {
    backgroundColorString = manifest.splash.backgroundColor;
  }

  // Default to white
  if (!backgroundColorString) {
    backgroundColorString = '#FFFFFF';
  }

  const { r, g, b } = _backgroundColorFromHexString(backgroundColorString);
  const backgroundViewNode = dom.getElementById(backgroundViewID);
  const backgroundViewColorNodes = backgroundViewNode.getElementsByTagName('color');
  let backgroundColorNode;
  for (let i = 0; i < backgroundViewColorNodes.length; i++) {
    const node = backgroundViewColorNodes[i];
    if (node.parentNode.getAttribute('id') !== backgroundViewID) {
      continue;
    }

    if (node.getAttribute('key') === 'backgroundColor') {
      backgroundColorNode = node;
      break;
    }
  }

  if (backgroundColorNode) {
    backgroundColorNode.setAttribute('red', r);
    backgroundColorNode.setAttribute('green', g);
    backgroundColorNode.setAttribute('blue', b);
  }
}

function _setBackgroundImageResizeMode(manifest, dom) {
  let backgroundViewMode = (() => {
    let mode;
    if (!manifest) {
      return ASPECT_FIT;
    }

    if (manifest.ios && manifest.ios.splash && manifest.ios.splash.resizeMode) {
      mode = manifest.ios.splash.resizeMode;
    } else if (manifest.splash && manifest.splash.resizeMode) {
      mode = manifest.splash.resizeMode;
    }

    return mode === 'cover' ? ASPECT_FILL : ASPECT_FIT;
  })();

  const backgroundImageViewNode = dom.getElementById(backgroundImageViewID);
  if (backgroundImageViewNode) {
    backgroundImageViewNode.setAttribute('contentMode', backgroundViewMode);
  }
}

function _maybeAbortForBackwardsCompatibility(context) {
  // before SDK 23, the ExpoKit template project didn't have the code or supporting files
  // to have a configurable splash screen. so don't try to move nonexistent files around
  // or edit them.
  let sdkVersion;
  try {
    sdkVersion = (0, (_ExponentTools || _load_ExponentTools()).parseSdkMajorVersion)(context.config.sdkVersion);
  } catch (_) {
    sdkVersion = 0; // :thinking_face:
  }
  if (sdkVersion < 23 && context.type === 'user' && !process.env.EXPO_VIEW_DIR) {
    return true;
  }
  return false;
}

exports.configureLaunchAssetsAsync = configureLaunchAssetsAsync;
//# sourceMappingURL=../__sourcemaps__/detach/IosLaunchScreen.js.map
